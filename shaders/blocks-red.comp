#version 460

layout (local_size_x = 16, local_size_y = 16) in;

layout (rgba16f, set = 0, binding = 0) uniform writeonly image2D outImage;


layout( push_constant ) uniform constants {
    vec4 data1;
    vec4 data2;
    vec4 data3;
    vec4 data4;
} pc;


#define TWO_PI 6.28318530718
#define PI     3.14159265359


float hash12(vec2 p) {
	vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

float atan2(in float y, in float x) {
    bool s = (abs(x) > abs(y));
    return mix(PI/2.0 - atan(x,y), atan(y,x), s);
}

struct squareData {
    vec2 uv;    // uv of each sqr
    vec2 id;    // id of each sqr
    float d;    // distance from center
    float r;    // polar angle
};

squareData squareCoords(vec2 uv) {
    squareData res;

    res.uv = fract(uv);
    res.uv = res.uv * 2.0 - 1.0;

    res.id = floor(uv);
    res.d = length(res.uv);
    res.r = (atan2(-res.uv.x, -res.uv.y) / TWO_PI) + 0.5;

    return res;
}

void main() {
    // image coordinates
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
	ivec2 size = imageSize(outImage);

    // push constants
    float mixValue = pc.data1.x;

    // coordinates
    vec2 uv = vec2(float(texelCoord.x)/(size.x), float(texelCoord.y)/(size.y));

    squareData sqr = squareCoords(uv * 20.0);

    float noise1 = hash12(sqr.id);
    float noise2 = hash12(sqr.id + 123456);
    float noiseMix = mix(noise1, noise2, mixValue);

    vec4 color = vec4(noiseMix, 0.0, 0.0, 1.0);

    imageStore(outImage, texelCoord, color);
}